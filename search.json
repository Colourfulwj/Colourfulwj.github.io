[{"title":"任意线性算符Hermite的分解","date":"2021-04-23T11:50:47.000Z","url":"/2021/04/23/%E4%BB%BB%E6%84%8F%E7%BA%BF%E6%80%A7%E7%AE%97%E7%AC%A6Hermite%E7%9A%84%E5%88%86%E8%A7%A3/","categories":[["undefined",""]],"content":"设有任意一个算符\\hat{A}（\\hat{A}可能是Hermite的，也可能不是Hermite的），其自伴算符为\\hat{A}^{+}，则构造两个新算符： \\hat{A}_{+}=\\frac{1}{2}\\left(\\hat{A}+\\hat{A}^{+}\\right) \\hat{A}_{-}=\\frac{1}{2 \\mathrm{i}}\\left(\\hat{A}-\\hat{A}^{+}\\right) \\begin{array}{l} \\hat{A}_{+}=\\frac{1}{2}\\left(\\hat{A}+\\hat{A}^{+}\\right) \\Rightarrow \\hat{A}_{+}^{+}=\\frac{1}{2}\\left(\\hat{A}^{+}+\\hat{A}^{++}\\right)=\\frac{1}{2}\\left(\\hat{A}^{+}+\\hat{A}\\right)=\\hat{A}_{+} \\\\ \\hat{A}_{-}=\\frac{1}{2 \\mathrm{i}}\\left(\\hat{A}-\\hat{A}^{+}\\right)=\\frac{-\\mathrm{i}}{2}\\left(\\hat{A}-\\hat{A}^{+}\\right) \\Rightarrow \\hat{A}_{-}^{+} \\\\ \\quad=\\frac{1}{2}\\left(\\hat{A}^{+}-\\hat{A}^{++}\\right) \\mathrm{i}=\\frac{\\mathrm{i}}{2}\\left(\\hat{A}^{+}-\\hat{A}\\right)=\\frac{-\\mathrm{i}}{2}\\left(\\hat{A}-\\hat{A}^{+}\\right)=\\hat{A}_{-} \\end{array}由上面的运算可以知道，\\hat{A}_{+}和\\hat{A}_{-}都是Hermite的。 \\begin{array}{l} \\hat{A}=\\hat{A}_{+}+\\mathrm{i} \\hat{A}_{-} \\\\ \\hat{A}^{+}=\\hat{A}_{+}-\\mathrm{i} \\hat{A}_{-} \\end{array}根据上面的关系式，可以快速得到一个算符的相关Hermite的算符。 例：已知粒子的坐标\\mathbf{r}和动量\\mathbf{p}为厄米算符，判断下列算符是否为厄米算符：\\mathbf{l} = \\mathbf{r} \\times \\mathbf{p} , \\mathbf{r} \\cdot \\mathbf{p} , \\mathbf{p} \\times \\mathbf{l} , \\mathbf{r} \\times \\mathbf{l}如果不是，试构造相应的厄米算符。 解：对于\\boldsymbol{l}=\\boldsymbol{r} \\times \\boldsymbol{p}，有 l_{x}=y p_{z}-z p_{y} l_{x}^{+}=\\left(y p_{z}-z p_{y}\\right)^{+}=\\left(p_{z}^{+} y^{+}-p_{y}^{+} z^{+}\\right)=\\left(p_{z} y-p y^{z}\\right)=y p_{z}-z p_{y}=l_{x}同理 l_{y}^{+}=l_{y}, \\quad l_{z}^{+}=l_{z}所以\\boldsymbol{l}=\\boldsymbol{r} \\times \\boldsymbol{p}=\\boldsymbol{l}^{+}是厄米算符。 对于\\boldsymbol{r} \\cdot \\boldsymbol{p}，有 \\begin{array}{l} (\\boldsymbol{r} \\cdot \\boldsymbol{p})^{+}=\\left(x p_{x}+y p_{y}+z p_{z}\\right)^{+}=p_{x}^{+} x^{+}+p_{y}^{+} y^{+}+p_{z}^{+} z^{+} \\\\ = p_{x} x+p_{y} y+p_{z} z \\neq x p_{x}+y p_{y}+z p_{z} \\end{array}所以 \\boldsymbol{r} \\cdot \\boldsymbol{p} 不是厄米算符，而 \\begin{aligned} (\\boldsymbol{r} \\cdot \\boldsymbol{p})^{+} &=\\boldsymbol{p} \\cdot \\boldsymbol{r}=p_{x} x+p_{y} y+p_{z} z=\\left(x p_{x}-\\mathrm{i} \\hbar\\right)+\\left(y p_{y}-\\mathrm{i} \\hbar\\right)+\\left(z p_{z}-\\mathrm{i} \\hbar\\right) \\\\ &=\\boldsymbol{r} \\cdot \\boldsymbol{p}-3 \\mathrm{i} \\hbar \\end{aligned}相应的厄米算符为\\frac{1}{2}[\\boldsymbol{r} \\cdot \\boldsymbol{p}+\\boldsymbol{p} \\cdot \\boldsymbol{r}]=\\boldsymbol{r} \\cdot \\boldsymbol{p}-3 \\mathrm{i} \\hbar / 2。 类似有(\\boldsymbol{p} \\times \\boldsymbol{l})^{+}=-(\\boldsymbol{l} \\times \\boldsymbol{p})，本身非厄米算符，但可以构造相应的厄米算符如下： \\frac{1}{2}[(p \\times l)-(l \\times \\bar{p})]=p \\times l-i \\hbar p(\\boldsymbol{r} \\times \\boldsymbol{l})^{+}=-(\\boldsymbol{l} \\times \\boldsymbol{r})$$本身也非厄米算符，但可以构造相应的厄米算符如下\\frac{1}{2}[(\\boldsymbol{r} \\times \\boldsymbol{l})-(\\boldsymbol{l} \\times \\boldsymbol{r})]=\\boldsymbol{r} \\times \\boldsymbol{l}-\\mathrm{i} \\hbar \\boldsymbol{r}$$"},{"title":"有符号数和无符号数的溢出判断","date":"2021-04-15T11:30:34.000Z","url":"/2021/04/15/%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E6%BA%A2%E5%87%BA%E5%88%A4%E6%96%AD/","categories":[["undefined",""]],"content":"复习微机原理时看到这样一个题 “试简述无符号数和有符号数运算产生溢出的判断方法有何不同。” 一看到着这题目觉得很懵逼，无从下手，于是查了些资料 无符号数判断溢出： 当最高为向更高位有进位（或借位）时产生溢出。 有符号数判断溢出： 最高位进位状态⊕次高位进位状态=1，则溢出。 ⊕为亦或，意思是当当最高位和次高位一个有进位一个没有进位是，则它们的异或结果为1，即结果产生溢出。"},{"title":"微机原理知识梳理","date":"2021-04-06T14:07:03.000Z","url":"/2021/04/06/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/","categories":[["undefined",""]],"content":"《微机原理与接口技术》（牟琦）知识梳理，复习自用。 2微型计算机系统基础系列计算机是指具有相同的基本指令系统和基本体系结构，但具有不同组成和实现的一系列不同型号的机器。 微处理器中主要的寄存器 1）指令寄存器 2）程序计数器 3）地址寄存器 4）数据寄存器 5）通用寄存器 6）程序状态字寄存器 地址分配 1）统一编址。将I/O端口和内存储器统一编址，即从整个内存空间中划出一个子空间给I/O端口，每个I/O端口分配一个地址，用访问内存的指令对I/O端口进行操作。 2）独立编址。内存储器和I/O端口地址空间各自独立编址，及I/O端口地址空间与内存储器地址空间分开设置，互不影响。 Intel系列机普遍采用I/O端口单独编制方式。CPU通过不同的指令来区分是访问内存还是访问IO端口，产生相应的控制信号。 标志寄存器FLAGS 1）状态标志反映了当前运算和操作结果的状态条件，可作为程序控制转移与否的依据。他们分别是CF、PF、AF、ZF、SF和OF。 CF(Carry Flag)：进位标志位。算术运算指令执行后，若运算结果的最高位产生敬畏或借位，则CF=1；否则CF=0。 PF(Parity Flag)：奇偶标志位。反应运算结果中1的个数时偶数还是奇数。运算指令执行后，若运算结果的低八位中含有偶数个1，则PF=1；否则PF=0。 AF(Auxiliary carry Flag )：辅助进位标志位。算术运算指令执行后，若运算结果的低4位向高4位(即D3位向D4位)产生进位或借位，则AF=1；否则AF=0。 ZF ( Zero Flag ) : 零标志位。若指令运算结果为0，则ZF = 1 ；否则ZF = 0 . SF((Sign Flag )：符号标志位。它与运算结果的最高位相同。若字节运算时D7位为1或字运算时D15位为1,则SF=1；否则SF=0。用补码运算时，它能反映结果的符号特征。 OF(Overflow Flag )：溢出标志位。当补码运算有溢出时(字节运算时为-128~+127,字运算时为-32768~+32767)，则OF=1；否则OF=0。 2）控制标志位则可以由指令进行置位和复位,用来控制CPU的操作,它包括DF、IF、TF。 DF(Direction Flag )：方向标志位。用于串操作指令，指定字符串处理时的方向。设置DF=0时，每执行一次串操作指令，地址指针内容将自动递增；设置DF=1时，地址指针内容将自动递减。可用指令设置或清除DF位。 IF(Interrupt Enable Flag )：中断允许标志位。用来控制8086是否允许接收外部中断请求。设置IF=1时，允许响应可屏蔽中断请求；设置IF=0时，禁止响应可屏蔽中断请求。可用指令设置或清除IF位。注意，IF的状态不影响非屏蔽中断请求(NMI)和CPU内部中断请求。 TF(Trap Flag )：单步标志位(或跟踪标志位)。它是为调试程序而设定的陷阱控制位。设置TF=1时，使CPU进入单步执行指令工作方式，此时CPU每执行完一条指令就自动产生一次内部中断；当该位复位后，CPU恢复正常工作。可用指令设置或清除TF位。 4寻址方式与指令系统4.1数据寻址方式4.1.1立即寻址指令的操作数（地址码）字段直接给出操作数本身，这种寻址方式称为立即寻址方式，这个操作数成为立即数。格式为： 这种寻址方式不能用于单操作数指令；在双操作数指令中，立即数也只能用于源操作数，不能用于目标操作数。 4.1.2寄存器寻址操作数在CPU内部的通用寄存器中，指令中指定寄存器名(机器指令中为寄存器的二进制编号)，这种寻址方式称为寄存器寻址。其汇编语言格式为: 可以使用以下寄存器： (1) 16位通用寄存器: AX、BX、CX、DX、SI、DI、BX、BX (2) 8位通用寄存器: AH、AL、BH、BL、CH、CL、DH、DL。 (3)段寄存器: CS、DS、SS、ES. (4) FLAGS标志寄存器。 4.1.3存储器寻址存储器寻址方式，就是通过形式地址计算出操作数有效地址的过程，包括直接寻址、寄存器间接寻址、寄存器相对寻址、基址加变址寻址、相对基址加变址寻址。 1）直接寻址操作数在内存中，操作数的邮箱地址有指令地址码字段直接给出，这种方式称为直接寻址。直接寻址方式默认的段寄存器是DS。 2）寄存器间接寻址操作数的有效地址被放在一个寄存器中，该寄存器由指令地址码字段指定，EA = [BX]/[BP]/[SI]/[DI]，这种方式称为寄存器间接寻址。 3）寄存器相对寻址操作数的有效地址为基址或变址寄存器与一个位移量之和（或之差），EA = [BX]/[BP]/[SI]/[DI] + DISP这种方式叫寄存器相对寻址*。 4）基址加变址寻址操作数的有效地址是两个指定寄存器的值之和，EA=[BX]/[BP] + [SI]/[DI]，这种方式称为基址加变址寻址。 5）相对基址加变址寻址存储单元的有效地址为一个基址寄存器、一个变址寄存器的内容及指令中指定的8位或16位位移量的和，EA=[BX]/[BP] + [SI]/[DI] + DISP ，这种方式称为相对基址加变址寻址。 Ⅳ）IO端口寻址 4.2指令寻址方式指令寻址方式是指确定下一条将要执行指令地址的方法，有顺序寻址方式和跳转寻址方式两种 跳转寻址方式1）段内直接寻址 2）段间直接寻址 3）段内间接寻址 4）段间间接寻址 4.3指令系统4.3.1数据传送指令1）通用数据传送指令 ①指令中两个操作数不能同为存储器操作数 ②CS不能作为目标操作数 ③段寄存器之间不能互相传送 ④立即数不能直接送入段寄存器 ⑤MOV指令不影响标志位 2）堆栈操作指令 ①PUSH、POP指令不能使用立即寻址方式，POP指令不能使用CS寄存器。 ②堆栈中数据的压入、弹出必须以字为单位进行，每次PUSH操作栈顶向低地址移动两字节，而每次POP操作栈顶向高地址移动两字节。 ③这两条堆栈指令不影响标志位。 3）地址传送指令 ①REG不能是段寄存器 ②三条指令均不影响标志位 4）标志寄存器传送指令 ①PUSHF是标志寄存器进栈指令，这条指令不影响标志位。 ②POPF是标志寄存器出栈指令，指令执行后标志位的状态取决于原来栈顶的内容。 ③PUSHF和POPF指令均是无操作数指令， LAHF和SAHF指令均是无操作数指令，隐含的操作数为AH。 ④SAHF指令可能会改变位于低八位SF、ZF、AF、PF和CF标志位，但不影响位于高八位的OF、DF、IF、TF标志位。 5）数据交换指令 ①DST、SRC可以是通用寄存器或存储器，不允许是段寄存器、立即数或IP寄存器 ②DST和SRC中，必须有一个是寄存器寻址方式，即两个存储单元之间不能直接互换数据 ③XCHG指令不影响标志位 6）换码指令 ①(AL)是一个八位无符号数， 所以表格中最多只能存放256个代码。 ②XLAT指令的执行结果不影响标志位 7）输入/输出指令 同之前的IO端口寻址 4.3.2算术运算指令1）加法与减法指令 指令类别 汇编格式 功能说明 影响标志位 不带进位加法指令 ADD DST, SRC DST ← SRC+DST 影响CF、OF、AF、SF、ZF、和PF 带进位加法指令 ADC DST, SRC DST ← SRC+DST+CF 影响CF、OF、AF、SF、ZF、和PF 自增指令 INC DST DST ← SRC+1 影响OF、AF、SF、ZF、和PF，不影响CF 不带进位减法指令 SUB DST, SRC DST ← SRC-DST 影响CF、OF、AF、SF、ZF、和PF 带进位减法指令 SBB DST, SRC DST ← SRC-DST-CF 影响CF、OF、AF、SF、ZF、和PF 自减指令 DEC DST DST ← SRC-1 影响OF、AF、SF、ZF、和PF，不影响CF 取负指令 NEG DST DST ← 0-DST 影响CF、OF、AF、SF、ZF、和PF 比较指令 CMP DST, SRC SRC-DST并设置标志位 影响CF、OF、AF、SF、ZF、和PF 两数AX和BX比较情况 ①两数相等。ZF = 1 ②AX和BX不相等，且均为无符号数。 若CF=0，则AX&gt;BX; 若CF=1，则AX&lt;BX。 ③AX和BX不相等，且为同号的带符号数。 当OF=0时，若SF=0，则AX&gt;BX；若SF=1，则AX&lt;BX。 ④AX和BX不相等，且为异号的带符号数。 当OF=1时， 若SF=1，则AX&gt;BX；若SF=0，则AX&lt;BX。 2）乘法指令和除法指令 指令类别 汇编格式 功能说明 影响标志位 带符号乘法运算符号 IMUL SRC 字节运算：AX←AL×SRC 对除CF和OF以外的标志位无定义 无符号乘法运算符号 MUL SRC 字运算：DS:AX←AL×SRC 对除CF和OF以外的标志位无定义 带符号除法运算符号 IDIV SRC 字节运算： AL←AX/SRC的商 AL ←AX/SRC的余数 对所有的标志位无定义 无符号除法运算符号 DIV SRC 字运算：AX←DX:AX/SRC的商 DX ←DX:AX/SRC的余数 对所有的标志位无定义 3）符号拓展指令字节拓展指令CBW：将AL中的符号位扩展到AH中，将一个字节拓展成一个字。 字拓展指令CWD：将AX中的符号位扩展到DX中，将一个字拓展成双字。 4）十进制算术运算指令 汇编格式 功能说明 影响标志位 DAA 压缩BCD码加法调整指令 影响AF、CF、PF、SF、ZF，对OF无定义 DAS 压缩BCD码减法调整指令 影响AF、CF、PF、SF、ZF，对OF无定义 AAA 非压缩BCD码加法调整指令 影响AF、CF，对其他状态标志无定义 AAS 非压缩BCD码减法调整指令 影响AF、CF，对其他状态标志无定义 AAM 非压缩BCD码乘法调整指令 影响SF、ZF、PF， 对OF、AF、CF无定义 AAD 非压缩BCD码除法调整指令 影响SF、ZF、PF，对AF、CF、OF无定义 4.3.3逻辑运算指令 汇编格式 功能说明 AND DST, SRC 逻辑与，DST←DST∧SRC OR DST, SRC 逻辑或，DST←DST∨SRC XOR DST, SRC 逻辑异或，DST←DST⊕SRC TEST DST, SRC 逻辑测试，DST∧SRC置各标志位 NOT DST 逻辑非，DST中各位取反 NOT指令不影响标志位，其余四条指令都使CF和OF为0，对AF无定义，按运算结果设置SF、PF、ZF。TEST指令与AND指令的运算功能完全相同，差别京在于不将结果送回目的，二十通过逻辑与运算影响标志位。 4.3.4位移指令1）算术移位指令①算术左移指令SAL，左移一次，最低位补0，最高位送入CF标志位，如图： 意义：左移n次，等于x2的n次幂。所以可用于有符号操作数做x2的n次幂运算。 ②算术右移指令SAR，右移一次，最高位保持不变，最低位送入CF标志位，如图： 意义：右移n次，等于/2的n次幂。所以可用于有符号操作数做/2的n次幂运算。 2）逻辑移位指令①逻辑左移SHL，同SAL,如图： 意义：同SAL ②逻辑右移SHR，右移一次，最高位补0.区别！最低位送入CF标志位。如图： 意义：用于实现无符号数/2的n次幂操作。 3）循环移位指令①循环左移指令ROL，左移一次，左移前的最高位送入最低位以及CF.如图： ②循环右移指令ROR，右移一次，右移前的最低位送入最高位以及CF.如图： ③带进位的循环左移RCL，左移一次，左移前的最高位送入CF，CF的内容送入最低位.如图： ④带进位的循环右移RCR，右移一次，右移前的最低位送入CF，CF的内容送入最高位.如图： 4.3.5串操作指令（不做要求）4.3.6程序控制指令(不影响标志位)1）转移指令①无条件转移指令JMP 寻址方式 汇编格式 功能说明 段内直接转移 JMP SHORT OPR (IP)←(IP)+8位位移量，段内直接短转移 JMP NEAR PTR OPR (IP)←(IP)+16位位移量，段内直接近转移 段内间接转移 JMP OPR1 (IP)←(EA)，OPR1为16位寄存器名或存储器寻址方式，EA为由OPR1指定的有效地址 段间直接转移 JMP FAR PTR OPR (IP)←目标地址的偏移地址，(CS)←目标地址的段地址 段间间接转移 JMP DWORD OPR (IP)←(EA)，EA为由OPR指定的有效地址，(CS)←(EA+2) ②条件转移指令 分类 汇编格式 条件说明 简单条件转移指令 JC OPR CF=1,有进位/有借位转移 JNC OPR CF=0,无进位/无借位转移 JS OPR SF=1,是负数转移 JNS OPR SF=0,是正数转移 JO OPR OF=1,有溢出转移 JNO OPR OF=0,无溢出转移 JZ/JE OPR ZF=1,相等/为0转移 JNZ/JNE OPR ZF=0,不相等/不为0转移 JP/JPE OPR PF=1,有偶数个1转移 JNP/JPO OPR PF=0,有奇数个1转移 无符号数条件转移指令 JA/JNBE OPR CF=0且ZF=0,高于/不低于或等于转移 JAE/JNB OPR CF=0或ZF=1,高于等于/不低于转移 JB/JNAE OPR CF=1且ZF=0,低于/不高于或等于转移 JBE/JNA OPR CF=1或ZF=1,低于等于/不高于转移 带符号数条件转移指令 JG/JNLE OPR SF=OF且ZF=0,大于/不小于或等于转移 JGE/JNL OPR SF=OF或ZF=1,大于或等于/不小于转移 JL/JNGE OPR SF≠OF且ZF=0,小于/不大于或等于转移 JLE/JNG OPR SF≠OF或ZF=1,小于或等于/不大于转移 ③循环控制指令 汇编格式 功能说明 LOOP OPR (CX)←(CX)-1，(CX)≠0时，转到OPR LOOPZ/LOOPE OPR (CX)←(CX)- 1，(CX)≠0且ZF=1时，转到OPR LOOPNZ/LOOPNE OPR (CX)←(CX)- 1，(CX)≠0且ZF=0时，转到OPR JCXZ OPR (CX)=0时转到OPR 2.子程序调用和返回 汇编格式 功能说明 操作 CALL NEAR PTR OPR 段内直接调用 (SP)←(SP)-2 ; CALL OPR ((SP)+1:(SP))←(IP) ; (IP)←(IP)+16位位移量 ; CALL OPR 段间直接调用 (SP)←(SP)-2 ; CALL WORD PTR OPR ((SP)+1:(SP))←(IP) ; (IP)←(EA) ; CALL FAR PTR OPR 段间直接调用 (SP)←(SP)-2 ; ((SP)+1:(SP))←(CS) ; (SP)←(SP)-2 ; ((SP)+1:(SP))←(IP) ; (IP)←OPR偏移地址 ； (CS)←OPR段地址 ； CALL DWORD PTR OPR 段间间接调用 (SP)←(SP)-2 ; ((SP)+1:(SP))←(CS) ; (SP)←(SP)-2 ; ((SP)+1:(SP))←(IP) ; (IP)←((EA)) ； (CS)←((EA+2)) ; RET RETF 段内/段间子程序返回 RET n RETF n 带偏移量n的段内/段间子程序返回 4.3.7处理器控制指令1）标志位处理指令 汇编格式 功能说明 CLC 进位位清0指令，(CF)←0 STC 进位位置1指令，(CF)←1 CMC 进位位取反指令，(CF)←(CF)取反 CLD 方向标志清0指令，(DF)←0 STD 方向标志置1指令，(DF)←1 CLI 中断标志清0指令，(IF)←0 STI 中断标志置1指令，(IF)←1 2）其他处理器指令 汇编格式 功能说明 HLT 暂停 WAIT 等待 LOCK 总线锁定前置 NOP 空操作 ESC DATA, SRC 外部设备换码 5汇编语言程序设计5.1汇编语言中的数据5.1.1常量常量是指在程序运行过程中不变的量，8086汇编语言允许的常量如下。 1）数值常量 汇编语言中数值常量可以是二进制、八进制、十进制或十六进制数。 2）字符串常量 包含在单引号中的若干字符形成字符串常量。 3）符号常量常量用符号名来代替就是符号常数。 5.1.2变量变量是存放在内存中某个存储区域中的数据，这些数据在程序运行期间随时可以修改。 变量的属性 ①段属性：变量所在段的起始地址，此值必须在一个段寄存器中。 ②偏移属性：该变量与段的起始地址之间相距的字节数。 ③类型属性：定义该变量的字节数。 可通过SEG、OFFSET和TYPE取得变量的属性。 变量的使用 ①变量名作为存储单元的直接地址 ②用合成运算符PTR可以临时改变变量类型 ③变量名作为相对寻址中的偏移量 ④变量名仅对应数据区第一个数据项"},{"title":"Schrodinger","date":"2021-03-16T14:11:36.000Z","url":"/2021/03/16/Schrodinger/","categories":[["undefined",""]],"content":"自由粒子的一般状态方程： i \\hbar \\frac{\\partial}{\\partial t} \\Psi(\\mathbf{r}, t)=-\\frac{\\hbar^{2}}{2 m} \\nabla^{2} \\Psi(\\mathbf{r}, t)在势场中的粒子的波函数满足的微分方程： i \\hbar \\frac{\\partial}{\\partial t} \\Psi(\\mathbf{r}, t)=-\\frac{\\hbar^{2}}{2 m} \\nabla^{2} \\Psi(\\mathbf{r}, t)+V(\\mathbf{r}) \\Psi(\\mathbf{r}, t)一维无限深方势阱 V(x)=\\left\\{\\begin{array}{ll}0, & 0"}]